<!DOCTYPE html>
<html lang="pt-br">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Secure Storage - Meus Códigos</title>
  <link rel="stylesheet" href="css/style.css">
  <link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism-tomorrow.min.css" rel="stylesheet">
    
  <style>
    /* Área de exibição do código e elementos relacionados */
    .code-display {
      margin: 2rem 0;
    }
    .file-name {
      font-size: 1.2rem;      
      color: var(--primary-color);
      margin-bottom: 0.3rem;
    }
    .file-description {
      font-size: 0.9rem;
      color: var(--text-secondary);
      margin-bottom: 1rem;
    }
    /* Container que envolve o código */
    .code-container {
      padding: 1rem;
      border-radius: 8px;
      overflow-x: auto;
      margin-bottom: 1rem;
      background-color: #282a36; /* Garantir fundo escuro */
    }
    .copy-button {
      display: inline-block;
      background-color: transparent;
      color: var(--primary-color);
      border: 2px solid var(--primary-color);
      padding: clamp(0.5rem, 2vw, 1rem);
      border-radius: 4px;
      text-decoration: none;
      transition: all 0.3s ease;
      font-size: clamp(0.9rem, 2vw, 1rem);
      cursor: pointer;
    }
    .copy-button:hover {
      background-color: rgba(61, 220, 132, 0.1);
      transform: translateY(-2px);
    }
  </style>
</head>
<body>
  <div class="container">
    <!-- Barra de navegação -->
    <nav>
      <div class="logo">
        <a href="index.html" style="text-decoration: none; color: var(--primary-color);">Voltar</a>
      </div>
    </nav>

    <!-- Seção de exibição do código -->
    <section class="code-display">
      <!-- Nome do arquivo -->
      <div class="file-name">SecureStorage.java</div>
      <!-- Descrição abaixo do nome do arquivo -->
      <div class="file-description">
       O SecureStorage é um sistema que utiliza SharedPreferences e o Android Keystore para armazenar dados de forma segura. Ele criptografa informações com o algoritmo AES-256/GCM, garantindo confidencialidade e integridade. A chave de criptografia é gerada e protegida pelo Keystore, enquanto os dados criptografados são armazenados no SharedPreferences. O sistema oferece métodos para salvar, recuperar, remover e limpar dados, sendo ideal para proteger informações sensíveis, como credenciais ou tokens, em aplicativos Android.
      </div>
          
      <div class="code-container">
        <pre><code class="language-java">
import android.content.Context;
import android.content.SharedPreferences;
import android.util.Base64;
import android.util.Log;

import java.nio.charset.StandardCharsets;
import java.security.KeyStore;

import android.security.keystore.KeyGenParameterSpec;
import android.security.keystore.KeyProperties;

import javax.crypto.Cipher;
import javax.crypto.KeyGenerator;
import javax.crypto.SecretKey;
import javax.crypto.spec.GCMParameterSpec;

public class SecureStorage {

    private static final String TAG = "SecureStorage";
    private static final String AES_MODE = "AES/GCM/NoPadding";
    private static final String ANDROID_KEY_STORE = "AndroidKeyStore";
    private static final int GCM_TAG_LENGTH = 128;
    private static final String KEY_ALIAS = "Seu Alias";
    private static final String PREF_NAME = "Seu Prefs";

    private final Context context;

    public SecureStorage(Context context) {
        this.context = context;
        createKeyIfNotExists();
    }

    private void createKeyIfNotExists() {
        try {
            KeyStore keyStore = KeyStore.getInstance(ANDROID_KEY_STORE);
            keyStore.load(null);

            if (!keyStore.containsAlias(KEY_ALIAS)) {
                KeyGenerator keyGenerator = KeyGenerator.getInstance("AES", ANDROID_KEY_STORE);
                KeyGenParameterSpec keySpec = new KeyGenParameterSpec.Builder(KEY_ALIAS,
                        KeyProperties.PURPOSE_ENCRYPT | KeyProperties.PURPOSE_DECRYPT)
                        .setBlockModes(KeyProperties.BLOCK_MODE_GCM)
                        .setEncryptionPaddings(KeyProperties.ENCRYPTION_PADDING_NONE)
                        .setKeySize(256) // 256 bits para maior segurança
                        .build();
                keyGenerator.init(keySpec);
                keyGenerator.generateKey();
            }
        } catch (Exception e) {
            //Logger.logError("SecureStorage", "Erro ao iniciar KeyStore.", e);
            throw new SecurityException("Erro ao inicializar o Android Keystore.", e);
        }
    }

    private String encrypt(String plainText) throws Exception {
        if (plainText == null || plainText.isEmpty()) {
            throw new IllegalArgumentException("O texto para criptografar não pode ser nulo ou vazio.");
        }

        KeyStore keyStore = KeyStore.getInstance(ANDROID_KEY_STORE);
        keyStore.load(null);

        SecretKey key = (SecretKey) keyStore.getKey(KEY_ALIAS, null);
        Cipher cipher = Cipher.getInstance(AES_MODE);
        cipher.init(Cipher.ENCRYPT_MODE, key);

        byte[] iv = cipher.getIV();
        byte[] encryptedData = cipher.doFinal(plainText.getBytes(StandardCharsets.UTF_8));

        return Base64.encodeToString(iv, Base64.NO_WRAP) + ":" + Base64.encodeToString(encryptedData, Base64.NO_WRAP);
    }

    private String decrypt(String encryptedData) throws Exception {
        if (encryptedData == null || !encryptedData.contains(":")) {
            throw new IllegalArgumentException("Dados criptografados inválidos.");
        }

        KeyStore keyStore = KeyStore.getInstance(ANDROID_KEY_STORE);
        keyStore.load(null);

        SecretKey key = (SecretKey) keyStore.getKey(KEY_ALIAS, null);
        Cipher cipher = Cipher.getInstance(AES_MODE);

        String[] parts = encryptedData.split(":");
        byte[] iv = Base64.decode(parts[0], Base64.NO_WRAP);
        byte[] cipherData = Base64.decode(parts[1], Base64.NO_WRAP);

        GCMParameterSpec spec = new GCMParameterSpec(GCM_TAG_LENGTH, iv);
        cipher.init(Cipher.DECRYPT_MODE, key, spec);

        byte[] decryptedData = cipher.doFinal(cipherData);
        return new String(decryptedData, StandardCharsets.UTF_8);
    }

    public void saveSecureData(String key, String value) {
        try {
            if (key == null || key.isEmpty() || value == null || value.isEmpty()) {
                throw new IllegalArgumentException("A chave ou valor não pode ser nulo ou vazio.");
            }

            String encryptedValue = encrypt(value);

            SharedPreferences preferences = context.getSharedPreferences(PREF_NAME, Context.MODE_PRIVATE);
            SharedPreferences.Editor editor = preferences.edit();
            editor.putString(key, encryptedValue);
            editor.apply();
        } catch (Exception e) {
           // Logger.logError("SecureStorage", "Erro ao armazenar dados de forma segura.", e);
            throw new SecurityException("Erro ao armazenar dados de forma segura.", e);
        }
    }

    public String getSecureData(String key) {
        try {
            if (key == null || key.isEmpty()) {
                throw new IllegalArgumentException("A chave não pode ser nula ou vazia.");
            }

            SharedPreferences preferences = context.getSharedPreferences(PREF_NAME, Context.MODE_PRIVATE);
            String encryptedValue = preferences.getString(key, null);

            if (encryptedValue == null) {
                return null;
            }

            return decrypt(encryptedValue);
        } catch (Exception e) {
           // Logger.logError("SecureStorage", "Erro ao recuperar dados.", e);
            throw new SecurityException("Erro ao recuperar dados de forma segura.", e);
        }
    }

    public void removeSecureData(String key) {
        SharedPreferences preferences = context.getSharedPreferences(PREF_NAME, Context.MODE_PRIVATE);
        SharedPreferences.Editor editor = preferences.edit();
        editor.remove(key).apply();
    }

    public void clearSecureData() {
        SharedPreferences preferences = context.getSharedPreferences(PREF_NAME, Context.MODE_PRIVATE);
        SharedPreferences.Editor editor = preferences.edit();
        editor.clear().apply();
    }

    public boolean contains(String key) {
        SharedPreferences preferences = context.getSharedPreferences(PREF_NAME, Context.MODE_PRIVATE);
        boolean contains = preferences.contains(key);
        return contains;
    }
}
    </code></pre>
      </div>
      <div class="file-name">Como usar:</div>
      <pre><code class="language-java">
          // Inicialização
SecureStorage secureStorage = new SecureStorage(context);

// Salvando dados
secureStorage.saveSecureData("usuario", "João Silva");

// Recuperando dados
String usuario = secureStorage.getSecureData("usuario");

// Removendo dados
secureStorage.removeSecureData("usuario");

// Limpando todos os dados
secureStorage.clearSecureData();
 </code></pre>
      
     
      <button class="copy-button" onclick="copyCode()">Copiar Código</button>
    </section>
  </div>

  <script>

    function copyCode() {
      const codeText = document.querySelector('.code-container pre').innerText;
      navigator.clipboard.writeText(codeText).then(() => {
        alert('Código copiado com sucesso!');
      }).catch((err) => {
        alert('Erro ao copiar o código: ' + err);
      });
    }
  </script>
      <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-java.min.js"></script>
</body>
</html>
